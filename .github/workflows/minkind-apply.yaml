name: MinKinD Apply E2Es

on:
  pull_request:
    branches: [ master ]

  # schedule:
  # - cron: '0 */3 * * *'

defaults:
  run:
    shell: bash
    working-directory: ./src/github.com/mattmoor/mink

jobs:
  cli-tests:
    name: e2e tests
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false # Keep running if one leg fails.
      matrix:
        # To cut down on redundant testing, test each suite against a
        # particular version of K8s.
        include:
        - k8s-version: v1.21.x
          selfhost-variant: dockerfile
        - k8s-version: v1.22.x
          selfhost-variant: buildpacks
        - k8s-version: v1.23.x
          selfhost-variant: ko

    env:
      GOPATH: ${{ github.workspace }}
      GO111MODULE: on
      GOFLAGS: -ldflags=-s -ldflags=-w -mod=vendor -tags=nostackdriver
      GGCR_EXPERIMENT_ESTARGZ: "1"
      KO_DOCKER_REPO: registry.local:5000/knative
      GATEWAY_OVERRIDE: kourier
      GATEWAY_NAMESPACE_OVERRIDE: mink-system
      SYSTEM_NAMESPACE: mink-system
      ARTIFACTS: ${{ github.workspace }}/artifacts

    steps:
    - name: Set up Go 1.17.x
      uses: actions/setup-go@v2
      with:
        go-version: 1.17.x

    - name: Install Dependencies
      working-directory: ./
      run: |
        echo '::group:: install ko'
        curl -L https://github.com/google/ko/releases/download/v0.8.3/ko_0.8.3_Linux_x86_64.tar.gz | tar xzf - ko
        chmod +x ./ko
        sudo mv ko /usr/local/bin
        echo '::endgroup::'

        echo '::group:: install crane'
        curl -L https://github.com/google/go-containerregistry/releases/download/v0.1.4/go-containerregistry_Linux_x86_64.tar.gz | tar xzf - crane
        chmod +x ./crane
        sudo mv crane /usr/local/bin
        echo '::endgroup::'

        echo '::group:: install yq'
        go get github.com/mikefarah/yq/v3
        echo '::endgroup::'

        echo '::group:: install goimports'
        go get golang.org/x/tools/cmd/goimports
        echo '::endgroup::'

        echo '::group:: install kn'
        curl -Lo ./kn https://github.com/knative/client/releases/download/v0.19.0/kn-linux-amd64
        chmod +x ./kn
        sudo mv kn /usr/local/bin
        echo '::endgroup::'

    - name: Check out mink
      uses: actions/checkout@v2
      with:
        path: ./src/github.com/mattmoor/mink

    - name: Setup Cluster
      working-directory: ./src/github.com/mattmoor/mink
      run: |
        ./hack/setup-kind.sh \
          --registry-url $(echo ${KO_DOCKER_REPO} | cut -d'/' -f 1) \
          --cluster-suffix c${{ github.run_id }}.local \
          --nodes 3 \
          --k8s-version ${{ matrix.k8s-version }}

    - name: Build and Install mink
      run: |
        ./hack/build.sh

        # Use mink to install things.
        mink install --replicas=3

        cat > $HOME/.mink.yaml <<EOF
        # Number of concurrent builds to allow.
        # We match this to nodes
        parallelism: 3

        # Bundle source context to here by default!
        bundle: ${KO_DOCKER_REPO}/bundle:latest

        # Send the resulting image here by default!
        image: |
          {{ if eq .Scheme "ko" }}
            ${KO_DOCKER_REPO}/{{ lower (join "ko-images" .Host .Path) }}
          {{ else if eq .Scheme "buildpack" }}
            ${KO_DOCKER_REPO}/{{ lower (join "buildpack-images" .Host .Path) }}
          {{ else if eq .Scheme "dockerfile" }}
            ${KO_DOCKER_REPO}/{{ lower (join "dockerfile-images" .Host .Path) }}
          {{ else if eq .Scheme "task" }}
            ${KO_DOCKER_REPO}/{{ lower (join "task-images" .Host .Path) }}
          {{ else if eq .Scheme "pipeline" }}
            ${KO_DOCKER_REPO}/{{ lower (join "pipeline-images" .Host .Path) }}
          {{ else }}
            BREAK THINGS
          {{ end }}
        EOF

    # Rebuild a self-hosted mink distributing builds using `ko publish`
    - name: mink apply (ko)
      if: matrix.selfhost-variant == 'ko'
      run: |
        kubectl delete jobs -nmink-system --all

        # Rebuild and redeploy.
        # TODO(mattmoor): Narrowing the scope here because ko asks for resources,
        # and nodes keep running out.
        mink apply -Rf config/core/deployments/dataplane.yaml

        kubectl rollout status -n ${SYSTEM_NAMESPACE} statefulsets/controlplane
        kubectl rollout status -n ${SYSTEM_NAMESPACE} daemonsets/dataplane

    # Rebuild a self-hosted mink distributing builds using `mink build`
    - name: mink apply (dockerfile)
      if: matrix.selfhost-variant == 'dockerfile'
      run: |
        kubectl delete jobs -nmink-system --all

        kubectl apply -f examples/kaniko.yaml

        # Turn our `ko://` configs into `dockerfile:///` configs with
        # references to synthetic Dockerfiles matching what ko does.
        ./dockerize.sh

        # Rebuild and redeploy again.
        mink apply -Rf generated/dockerfile/config/core

        kubectl rollout status -n ${SYSTEM_NAMESPACE} statefulsets/controlplane
        kubectl rollout status -n ${SYSTEM_NAMESPACE} daemonsets/dataplane

    - name: mink apply (buildpack)
      if: matrix.selfhost-variant == 'buildpacks'
      run: |
        # TODO(mattmoor): Don't delete these jobs, since we don't conflict with
        # (or replace!) them below, and unless this successfully runs, we won't
        # pass the smoke test.
        # kubectl delete jobs -nmink-system --all

        # Turn our `ko://` configs into `buildpack:///` configs.
        ./buildpackerize.sh

        # Rebuild and redeploy again.
        # TODO(mattmoor): buildpacks change enough that this is not a particularly good test.
        # Lots of assumptions about /ko-app/foo and uid abound, which complicate this translation,
        # so scope things to IMC for now.
        mink apply -Rf generated/buildpacks/config/in-memory

        kubectl rollout status -n ${SYSTEM_NAMESPACE} statefulsets/controlplane
        kubectl rollout status -n ${SYSTEM_NAMESPACE} daemonsets/dataplane

    # Finally, run a smoke test.
    - name: Run smoke test
      run: |
        kn service create autoscale-go --image=gcr.io/knative-samples/autoscale-go:0.1

        # Extract the IP from the xip.io hostname, and put it in /etc/hosts to avoid flakes.
        URL="$(kn service describe autoscale-go -o url)"
        HOST="$(echo ${URL} | cut -d'/' -f 3)"
        IP="$(echo ${HOST} | cut -d'.' -f 3-6)"
        sudo echo ${IP} ${HOST} | sudo tee -a /etc/hosts

        # Make sure we can curl the sample.
        curl "${URL}/?sleep=100"

    - uses: chainguard-dev/actions/kind-diag@main
      if: ${{ failure() }}
